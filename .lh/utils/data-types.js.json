{
    "sourceFile": "utils/data-types.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1730291256970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1730291299849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,13 @@\n+// Data Types and Structures:\r\n+\r\n+// Energy reading format\r\n+// Time range structure\r\n+// Message structure for chat\r\n+// Analysis result structure\r\n+// Data validation functions\r\n+// Data aggregation helpers\r\n+\r\n // Energy reading data structure\r\n export const createEnergyReading = (timestamp, consumption) => {\r\n     return {\r\n       timestamp: new Date(timestamp),\r\n"
                }
            ],
            "date": 1730291256970,
            "name": "Commit-0",
            "content": "// Energy reading data structure\r\nexport const createEnergyReading = (timestamp, consumption) => {\r\n    return {\r\n      timestamp: new Date(timestamp),\r\n      consumption: Number(consumption)\r\n    };\r\n  };\r\n  \r\n  // Time range structure\r\n  export const createTimeRange = (start, end) => {\r\n    return {\r\n      start: new Date(start),\r\n      end: new Date(end)\r\n    };\r\n  };\r\n  \r\n  // Message structure for chat\r\n  export const createMessage = (content, type = 'user') => {\r\n    return {\r\n      id: Date.now().toString(),\r\n      content,\r\n      type, // 'user' or 'system'\r\n      timestamp: new Date(),\r\n      metadata: {} // For additional data like analysis results\r\n    };\r\n  };\r\n  \r\n  // Analysis result structure\r\n  export const createAnalysisResult = (timeRange, data) => {\r\n    return {\r\n      timeRange,\r\n      actualConsumption: data.reduce((sum, reading) => sum + reading.consumption, 0),\r\n      averageHourly: data.reduce((sum, reading) => sum + reading.consumption, 0) / data.length,\r\n      readings: data,\r\n      summary: null  // Will be filled by analysis engine\r\n    };\r\n  };\r\n  \r\n  // Validation functions\r\n  export const isValidEnergyReading = (reading) => {\r\n    return (\r\n      reading &&\r\n      reading.timestamp instanceof Date &&\r\n      !isNaN(reading.timestamp) &&\r\n      typeof reading.consumption === 'number' &&\r\n      !isNaN(reading.consumption) &&\r\n      reading.consumption >= 0\r\n    );\r\n  };\r\n  \r\n  export const isValidTimeRange = (range) => {\r\n    return (\r\n      range &&\r\n      range.start instanceof Date &&\r\n      range.end instanceof Date &&\r\n      !isNaN(range.start) &&\r\n      !isNaN(range.end) &&\r\n      range.start <= range.end\r\n    );\r\n  };\r\n  \r\n  // Helper function to validate and clean data\r\n  export const cleanEnergyData = (rawData) => {\r\n    return rawData\r\n      .map(row => {\r\n        try {\r\n          const reading = createEnergyReading(row.timestamp, row.consumption);\r\n          return isValidEnergyReading(reading) ? reading : null;\r\n        } catch (error) {\r\n          console.error('Error cleaning data row:', error);\r\n          return null;\r\n        }\r\n      })\r\n      .filter(reading => reading !== null);\r\n  };\r\n  \r\n  // Data aggregation helpers\r\n  export const aggregateReadings = (readings, interval = 'hour') => {\r\n    const grouped = readings.reduce((acc, reading) => {\r\n      let key;\r\n      const date = reading.timestamp;\r\n  \r\n      switch (interval) {\r\n        case 'hour':\r\n          key = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours()).getTime();\r\n          break;\r\n        case 'day':\r\n          key = new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();\r\n          break;\r\n        default:\r\n          key = date.getTime();\r\n      }\r\n  \r\n      if (!acc[key]) {\r\n        acc[key] = {\r\n          timestamp: new Date(key),\r\n          readings: [],\r\n          total: 0,\r\n          count: 0\r\n        };\r\n      }\r\n  \r\n      acc[key].readings.push(reading);\r\n      acc[key].total += reading.consumption;\r\n      acc[key].count += 1;\r\n  \r\n      return acc;\r\n    }, {});\r\n  \r\n    return Object.values(grouped).map(group => ({\r\n      timestamp: group.timestamp,\r\n      consumption: group.total / group.count\r\n    }));\r\n  };"
        }
    ]
}