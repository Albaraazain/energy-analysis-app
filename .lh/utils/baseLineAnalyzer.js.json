{
    "sourceFile": "utils/baseLineAnalyzer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1730296708327,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1730299916675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,20 @@\n+// BaselineAnalyzer Class:\r\n+\r\n+// Calculates usage baselines\r\n+// Detects patterns in consumption\r\n+// Analyzes hourly and daily patterns\r\n+// Identifies peak usage periods\r\n+// Provides pattern descriptions\r\n+\r\n+\r\n+// Pattern Analysis Features:\r\n+\r\n+// Hourly patterns (morning, afternoon, evening, night)\r\n+// Daily patterns (weekday vs weekend)\r\n+// Peak usage detection\r\n+// Usage variability analysis\r\n+\r\n import _ from 'lodash';\r\n \r\n class BaselineAnalyzer {\r\n   constructor(data) {\r\n"
                }
            ],
            "date": 1730296708327,
            "name": "Commit-0",
            "content": "import _ from 'lodash';\r\n\r\nclass BaselineAnalyzer {\r\n  constructor(data) {\r\n    this.data = data;\r\n    this.baselineCache = new Map();\r\n  }\r\n\r\n  // Calculate baseline for different time periods\r\n  calculateBaseline(timeRange, groupingInterval = 'hour') {\r\n    const cacheKey = `${timeRange.start}-${timeRange.end}-${groupingInterval}`;\r\n    \r\n    if (this.baselineCache.has(cacheKey)) {\r\n      return this.baselineCache.get(cacheKey);\r\n    }\r\n\r\n    // Group data by the specified interval\r\n    const groupedData = _.groupBy(this.data, (reading) => {\r\n      const date = new Date(reading.timestamp);\r\n      switch (groupingInterval) {\r\n        case 'hour':\r\n          return date.getHours();\r\n        case 'dayOfWeek':\r\n          return date.getDay();\r\n        case 'dayOfMonth':\r\n          return date.getDate();\r\n        default:\r\n          return date.getHours();\r\n      }\r\n    });\r\n\r\n    // Calculate averages for each group\r\n    const baseline = _.mapValues(groupedData, (readings) => {\r\n      const values = readings.map(r => r.consumption);\r\n      return {\r\n        average: _.mean(values),\r\n        median: _.sortBy(values)[Math.floor(values.length / 2)],\r\n        stdDev: this.calculateStdDev(values),\r\n        min: _.min(values),\r\n        max: _.max(values),\r\n        samples: values.length\r\n      };\r\n    });\r\n\r\n    this.baselineCache.set(cacheKey, baseline);\r\n    return baseline;\r\n  }\r\n\r\n  // Calculate standard deviation\r\n  calculateStdDev(values) {\r\n    const mean = _.mean(values);\r\n    const squareDiffs = values.map(value => Math.pow(value - mean, 2));\r\n    return Math.sqrt(_.mean(squareDiffs));\r\n  }\r\n\r\n  // Detect patterns in usage\r\n  detectPatterns(timeRange) {\r\n    const hourlyBaseline = this.calculateBaseline(timeRange, 'hour');\r\n    const dailyBaseline = this.calculateBaseline(timeRange, 'dayOfWeek');\r\n\r\n    return {\r\n      hourlyPatterns: this.analyzeHourlyPatterns(hourlyBaseline),\r\n      dailyPatterns: this.analyzeDailyPatterns(dailyBaseline),\r\n      peakUsagePeriods: this.findPeakPeriods(hourlyBaseline)\r\n    };\r\n  }\r\n\r\n  // Analyze hourly consumption patterns\r\n  analyzeHourlyPatterns(hourlyBaseline) {\r\n    const periods = {\r\n      morning: _.range(6, 12),    // 6 AM - 12 PM\r\n      afternoon: _.range(12, 17),  // 12 PM - 5 PM\r\n      evening: _.range(17, 22),    // 5 PM - 10 PM\r\n      night: [..._.range(22, 24), ..._.range(0, 6)] // 10 PM - 6 AM\r\n    };\r\n\r\n    return _.mapValues(periods, hours => {\r\n      const relevantData = hours.map(hour => hourlyBaseline[hour]?.average || 0);\r\n      return {\r\n        averageUsage: _.mean(relevantData),\r\n        totalHours: hours.length,\r\n        peak: _.max(relevantData),\r\n        description: this.describePeriodUsage(relevantData)\r\n      };\r\n    });\r\n  }\r\n\r\n  // Analyze daily patterns\r\n  analyzeDailyPatterns(dailyBaseline) {\r\n    const weekdays = _.range(1, 6);  // Monday to Friday\r\n    const weekend = [0, 6];          // Sunday and Saturday\r\n\r\n    return {\r\n      weekday: {\r\n        average: _.mean(weekdays.map(day => dailyBaseline[day]?.average || 0)),\r\n        pattern: this.describeDayPattern(weekdays, dailyBaseline)\r\n      },\r\n      weekend: {\r\n        average: _.mean(weekend.map(day => dailyBaseline[day]?.average || 0)),\r\n        pattern: this.describeDayPattern(weekend, dailyBaseline)\r\n      }\r\n    };\r\n  }\r\n\r\n  // Find peak usage periods\r\n  findPeakPeriods(hourlyBaseline) {\r\n    const threshold = _.mean(Object.values(hourlyBaseline).map(data => data.average)) * 1.5;\r\n    \r\n    return Object.entries(hourlyBaseline)\r\n      .filter(([, data]) => data.average > threshold)\r\n      .map(([hour, data]) => ({\r\n        hour: parseInt(hour),\r\n        usage: data.average,\r\n        frequency: data.samples,\r\n        significance: (data.average - threshold) / threshold\r\n      }))\r\n      .sort((a, b) => b.significance - a.significance);\r\n  }\r\n\r\n  // Generate description for period usage\r\n  describePeriodUsage(values) {\r\n    const average = _.mean(values);\r\n    const max = _.max(values);\r\n    const min = _.min(values);\r\n    \r\n    if (max > average * 1.5) return 'High variability with significant peaks';\r\n    if (max < average * 1.2) return 'Consistent usage pattern';\r\n    return 'Moderate variation in usage';\r\n  }\r\n\r\n  // Generate description for daily patterns\r\n  describeDayPattern(days, baseline) {\r\n    const values = days.map(day => baseline[day]?.average || 0);\r\n    const average = _.mean(values);\r\n    const variation = this.calculateStdDev(values) / average;\r\n\r\n    if (variation < 0.1) return 'Very consistent day-to-day usage';\r\n    if (variation < 0.2) return 'Fairly consistent usage with some variation';\r\n    return 'Highly variable day-to-day usage';\r\n  }\r\n\r\n  // Compare usage against baseline\r\n  compareToBaseline(readings, baseline) {\r\n    return readings.map(reading => {\r\n      const hour = new Date(reading.timestamp).getHours();\r\n      const baselineForHour = baseline[hour];\r\n\r\n      if (!baselineForHour) return null;\r\n\r\n      const deviation = (reading.consumption - baselineForHour.average) / baselineForHour.stdDev;\r\n      \r\n      return {\r\n        ...reading,\r\n        baselineAverage: baselineForHour.average,\r\n        deviation,\r\n        isAnomaly: Math.abs(deviation) > 2, // More than 2 standard deviations\r\n        percentageDiff: ((reading.consumption - baselineForHour.average) / baselineForHour.average) * 100\r\n      };\r\n    }).filter(Boolean);\r\n  }\r\n}\r\n\r\nexport default BaselineAnalyzer;"
        }
    ]
}