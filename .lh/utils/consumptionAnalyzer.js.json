{
    "sourceFile": "utils/consumptionAnalyzer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1730296777577,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1730299916701,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,12 @@\n-# File: src/utils/consumptionAnalyzer.js\r\n+// ConsumptionAnalyzer Class:\r\n \r\n+// Detailed consumption analysis\r\n+// Statistical calculations\r\n+// Trend detection\r\n+// Variability analysis\r\n+// Pattern recognition\r\n+\r\n import _ from 'lodash';\r\n \r\n class ConsumptionAnalyzer {\r\n   constructor(data) {\r\n"
                }
            ],
            "date": 1730296777577,
            "name": "Commit-0",
            "content": "# File: src/utils/consumptionAnalyzer.js\r\n\r\nimport _ from 'lodash';\r\n\r\nclass ConsumptionAnalyzer {\r\n  constructor(data) {\r\n    this.data = data;\r\n  }\r\n\r\n  // Analyze consumption for a specific time period\r\n  analyzeTimeRange(startTime, endTime) {\r\n    const periodData = this.getDataInRange(startTime, endTime);\r\n    \r\n    if (periodData.length === 0) {\r\n      return {\r\n        error: 'No data available for the specified time range'\r\n      };\r\n    }\r\n\r\n    const analysis = {\r\n      totalConsumption: this.calculateTotal(periodData),\r\n      averageConsumption: this.calculateAverage(periodData),\r\n      statistics: this.calculateStatistics(periodData),\r\n      trends: this.analyzeTrends(periodData),\r\n      summary: this.generateSummary(periodData)\r\n    };\r\n\r\n    return analysis;\r\n  }\r\n\r\n  // Get data within a specific time range\r\n  getDataInRange(startTime, endTime) {\r\n    return this.data.filter(reading => {\r\n      const timestamp = new Date(reading.timestamp);\r\n      return timestamp >= startTime && timestamp <= endTime;\r\n    });\r\n  }\r\n\r\n  // Calculate total consumption\r\n  calculateTotal(data) {\r\n    return _.sumBy(data, 'consumption');\r\n  }\r\n\r\n  // Calculate average consumption\r\n  calculateAverage(data) {\r\n    return this.calculateTotal(data) / data.length;\r\n  }\r\n\r\n  // Calculate detailed statistics\r\n  calculateStatistics(data) {\r\n    const values = data.map(d => d.consumption);\r\n    const sorted = _.sortBy(values);\r\n    \r\n    return {\r\n      min: _.min(values),\r\n      max: _.max(values),\r\n      median: sorted[Math.floor(sorted.length / 2)],\r\n      q1: sorted[Math.floor(sorted.length / 4)],\r\n      q3: sorted[Math.floor(3 * sorted.length / 4)],\r\n      standardDeviation: this.calculateStandardDeviation(values),\r\n      variance: this.calculateVariance(values)\r\n    };\r\n  }\r\n\r\n  // Calculate standard deviation\r\n  calculateStandardDeviation(values) {\r\n    const variance = this.calculateVariance(values);\r\n    return Math.sqrt(variance);\r\n  }\r\n\r\n  // Calculate variance\r\n  calculateVariance(values) {\r\n    const mean = _.mean(values);\r\n    const squaredDiffs = values.map(v => Math.pow(v - mean, 2));\r\n    return _.mean(squaredDiffs);\r\n  }\r\n\r\n  // Analyze consumption trends\r\n  analyzeTrends(data) {\r\n    const hourlyAverages = this.groupByHour(data);\r\n    const movingAverage = this.calculateMovingAverage(data, 3); // 3-hour moving average\r\n    \r\n    return {\r\n      hourlyPattern: hourlyAverages,\r\n      movingAverage,\r\n      trend: this.detectTrend(data),\r\n      variability: this.analyzeVariability(data)\r\n    };\r\n  }\r\n\r\n  // Group data by hour and calculate averages\r\n  groupByHour(data) {\r\n    return _.chain(data)\r\n      .groupBy(d => new Date(d.timestamp).getHours())\r\n      .mapValues(group => ({\r\n        average: _.meanBy(group, 'consumption'),\r\n        count: group.length\r\n      }))\r\n      .value();\r\n  }\r\n\r\n  // Calculate moving average\r\n  calculateMovingAverage(data, window) {\r\n    const result = [];\r\n    for (let i = 0; i < data.length - window + 1; i++) {\r\n      const windowData = data.slice(i, i + window);\r\n      result.push({\r\n        timestamp: data[i + Math.floor(window/2)].timestamp,\r\n        value: _.meanBy(windowData, 'consumption')\r\n      });\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Detect overall trend in consumption\r\n  detectTrend(data) {\r\n    const values = data.map(d => d.consumption);\r\n    const n = values.length;\r\n    \r\n    if (n < 2) return 'insufficient_data';\r\n\r\n    // Calculate simple linear regression\r\n    const xMean = (n - 1) / 2;\r\n    const yMean = _.mean(values);\r\n    \r\n    let numerator = 0;\r\n    let denominator = 0;\r\n    \r\n    values.forEach((y, x) => {\r\n      numerator += (x - xMean) * (y - yMean);\r\n      denominator += Math.pow(x - xMean, 2);\r\n    });\r\n\r\n    const slope = numerator / denominator;\r\n\r\n    return {\r\n      direction: slope > 0 ? 'increasing' : slope < 0 ? 'decreasing' : 'stable',\r\n      magnitude: Math.abs(slope),\r\n      confidence: this.calculateTrendConfidence(slope, values)\r\n    };\r\n  }\r\n\r\n  // Calculate confidence in trend detection\r\n  calculateTrendConfidence(slope, values) {\r\n    const variance = this.calculateVariance(values);\r\n    return Math.min(Math.abs(slope) / Math.sqrt(variance), 1);\r\n  }\r\n\r\n  // Analyze variability in consumption\r\n  analyzeVariability(data) {\r\n    const hourlyVariation = this.calculateHourlyVariation(data);\r\n    const overall = this.calculateStatistics(data);\r\n\r\n    return {\r\n      hourly: hourlyVariation,\r\n      coefficientOfVariation: overall.standardDeviation / overall.median,\r\n      volatility: this.calculateVolatility(data)\r\n    };\r\n  }\r\n\r\n  // Calculate hourly variation\r\n  calculateHourlyVariation(data) {\r\n    const grouped = this.groupByHour(data);\r\n    \r\n    return _.mapValues(grouped, group => ({\r\n      average: group.average,\r\n      variation: Math.sqrt(\r\n        _.sumBy(data, d => Math.pow(d.consumption - group.average, 2)) / data.length\r\n      )\r\n    }));\r\n  }\r\n\r\n  // Calculate volatility (rate of change)\r\n  calculateVolatility(data) {\r\n    if (data.length < 2) return 0;\r\n\r\n    const changes = [];\r\n    for (let i = 1; i < data.length; i++) {\r\n      const percentChange = (data[i].consumption - data[i-1].consumption) / data[i-1].consumption;\r\n      changes.push(percentChange);\r\n    }\r\n\r\n    return {\r\n      average: _.mean(changes),\r\n      maximum: _.max(changes),\r\n      standardDeviation: this.calculateStandardDeviation(changes)\r\n    };\r\n  }\r\n\r\n  // Generate a summary of the analysis\r\n  generateSummary(data) {\r\n    const stats = this.calculateStatistics(data);\r\n    const trends = this.analyzeTrends(data);\r\n\r\n    return {\r\n      averageConsumption: this.calculateAverage(data),\r\n      totalConsumption: this.calculateTotal(data),\r\n      peakConsumption: stats.max,\r\n      lowestConsumption: stats.min,\r\n      trend: trends.trend.direction,\r\n      variability: trends.variability.coefficientOfVariation,\r\n      reliability: 1 - (stats.standardDeviation / stats.median)\r\n    };\r\n  }\r\n}\r\n\r\nexport default ConsumptionAnalyzer;"
        }
    ]
}