{
    "sourceFile": "utils/quesry-parser.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1730291540567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1730299916727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,4 @@\n-# File: src/utils/queryParser.js\r\n-\r\n import { getDateRange, parseFlexibleDate } from './dateUtils';\r\n \r\n // Query types for different kinds of analysis\r\n const QUERY_TYPES = {\r\n"
                }
            ],
            "date": 1730291540567,
            "name": "Commit-0",
            "content": "# File: src/utils/queryParser.js\r\n\r\nimport { getDateRange, parseFlexibleDate } from './dateUtils';\r\n\r\n// Query types for different kinds of analysis\r\nconst QUERY_TYPES = {\r\n  USAGE_INQUIRY: 'usage_inquiry',      // \"How much energy did I use...\"\r\n  COMPARISON: 'comparison',            // \"Was my usage higher than...\"\r\n  PATTERN: 'pattern',                  // \"What's my typical usage...\"\r\n  ANOMALY: 'anomaly',                  // \"Any unusual consumption...\"\r\n  UNKNOWN: 'unknown'\r\n};\r\n\r\nclass QueryParser {\r\n  constructor() {\r\n    // Keywords for different types of queries\r\n    this.keywords = {\r\n      usage: ['use', 'used', 'usage', 'consume', 'consumed', 'consumption'],\r\n      comparison: ['compare', 'compared', 'higher', 'lower', 'more', 'less', 'than'],\r\n      pattern: ['typical', 'usually', 'normal', 'average', 'pattern', 'regularly'],\r\n      anomaly: ['unusual', 'abnormal', 'strange', 'unexpected', 'spike', 'different']\r\n    };\r\n\r\n    // Common time expressions\r\n    this.timeExpressions = {\r\n      relative: [\r\n        'yesterday',\r\n        'last night',\r\n        'this morning',\r\n        'last week',\r\n        'past week',\r\n        'last month',\r\n        'past month',\r\n        'today'\r\n      ],\r\n      specific: [\r\n        'january', 'february', 'march', 'april', 'may', 'june',\r\n        'july', 'august', 'september', 'october', 'november', 'december',\r\n        'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'\r\n      ]\r\n    };\r\n  }\r\n\r\n  parseQuery(query) {\r\n    const lowercaseQuery = query.toLowerCase();\r\n    \r\n    return {\r\n      type: this.detectQueryType(lowercaseQuery),\r\n      timeRange: this.extractTimeRange(lowercaseQuery),\r\n      keywords: this.extractKeywords(lowercaseQuery),\r\n      confidence: this.calculateConfidence(lowercaseQuery)\r\n    };\r\n  }\r\n\r\n  detectQueryType(query) {\r\n    // Count keyword matches for each type\r\n    const matches = Object.entries(this.keywords).reduce((acc, [type, keywords]) => {\r\n      acc[type] = keywords.filter(keyword => query.includes(keyword)).length;\r\n      return acc;\r\n    }, {});\r\n\r\n    // Find the type with the most matches\r\n    const maxMatches = Math.max(...Object.values(matches));\r\n    const queryType = Object.entries(matches).find(([, count]) => count === maxMatches)?.[0];\r\n\r\n    switch (queryType) {\r\n      case 'usage':\r\n        return QUERY_TYPES.USAGE_INQUIRY;\r\n      case 'comparison':\r\n        return QUERY_TYPES.COMPARISON;\r\n      case 'pattern':\r\n        return QUERY_TYPES.PATTERN;\r\n      case 'anomaly':\r\n        return QUERY_TYPES.ANOMALY;\r\n      default:\r\n        return QUERY_TYPES.UNKNOWN;\r\n    }\r\n  }\r\n\r\n  extractTimeRange(query) {\r\n    // Check for relative time expressions first\r\n    for (const expr of this.timeExpressions.relative) {\r\n      if (query.includes(expr)) {\r\n        switch (expr) {\r\n          case 'yesterday':\r\n            return getDateRange('yesterday');\r\n          case 'last week':\r\n          case 'past week':\r\n            return getDateRange('lastWeek');\r\n          case 'last month':\r\n          case 'past month':\r\n            return getDateRange('lastMonth');\r\n          case 'today':\r\n            return getDateRange('today');\r\n          // Add more cases as needed\r\n        }\r\n      }\r\n    }\r\n\r\n    // Look for date patterns (e.g., \"January 5th\", \"last Monday\")\r\n    const dateMatch = this.findDatePattern(query);\r\n    if (dateMatch) {\r\n      const date = parseFlexibleDate(dateMatch);\r\n      if (date) {\r\n        return {\r\n          start: new Date(date.setHours(0, 0, 0, 0)),\r\n          end: new Date(date.setHours(23, 59, 59, 999))\r\n        };\r\n      }\r\n    }\r\n\r\n    // Default to recent period if no time specified\r\n    return getDateRange('lastWeek');\r\n  }\r\n\r\n  findDatePattern(query) {\r\n    // Look for month names\r\n    const monthMatch = this.timeExpressions.specific\r\n      .filter(month => query.includes(month))\r\n      .join(' ');\r\n    \r\n    if (monthMatch) {\r\n      // Look for nearby numbers (e.g., \"january 5th\")\r\n      const datePattern = new RegExp(`${monthMatch}\\\\s+(\\\\d+)(?:st|nd|rd|th)?`, 'i');\r\n      const match = query.match(datePattern);\r\n      if (match) {\r\n        return match[0];\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  extractKeywords(query) {\r\n    // Extract all matching keywords\r\n    const matches = new Set();\r\n    \r\n    Object.values(this.keywords).flat().forEach(keyword => {\r\n      if (query.includes(keyword)) {\r\n        matches.add(keyword);\r\n      }\r\n    });\r\n\r\n    return Array.from(matches);\r\n  }\r\n\r\n  calculateConfidence(query) {\r\n    // Simple confidence calculation based on keyword matches and time expression clarity\r\n    let confidence = 0;\r\n\r\n    // Add points for keyword matches\r\n    const keywordMatches = this.extractKeywords(query).length;\r\n    confidence += keywordMatches * 0.2; // 20% per keyword match\r\n\r\n    // Add points for time expression clarity\r\n    const hasTimeExpression = this.timeExpressions.relative\r\n      .concat(this.timeExpressions.specific)\r\n      .some(expr => query.includes(expr));\r\n    \r\n    if (hasTimeExpression) {\r\n      confidence += 0.3; // 30% for clear time expression\r\n    }\r\n\r\n    // Cap at 1.0\r\n    return Math.min(confidence, 1);\r\n  }\r\n}\r\n\r\nexport {\r\n  QueryParser,\r\n  QUERY_TYPES\r\n};"
        }
    ]
}