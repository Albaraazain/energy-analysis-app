{
    "sourceFile": "src/hooks/usePerformanceOptimization.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1730298796198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1730298796198,
            "name": "Commit-0",
            "content": "\r\nimport { useState, useCallback, useRef, useEffect } from 'react';\r\nimport { debounce, processInChunks, getVisibleItems } from '../utils/performance';\r\n\r\n// Hook for virtual scrolling\r\nexport const useVirtualScroll = (items, itemHeight = 50) => {\r\n  const [visibleItems, setVisibleItems] = useState([]);\r\n  const [scrollTop, setScrollTop] = useState(0);\r\n  const containerRef = useRef(null);\r\n\r\n  const updateVisibleItems = useCallback(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    const { height } = containerRef.current.getBoundingClientRect();\r\n    const { items: visible, startIndex } = getVisibleItems(\r\n      items,\r\n      scrollTop,\r\n      height,\r\n      itemHeight\r\n    );\r\n\r\n    setVisibleItems(visible.map((item, index) => ({\r\n      ...item,\r\n      virtualIndex: startIndex + index\r\n    })));\r\n  }, [items, scrollTop, itemHeight]);\r\n\r\n  const handleScroll = useCallback((e) => {\r\n    setScrollTop(e.target.scrollTop);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    updateVisibleItems();\r\n  }, [updateVisibleItems, items, scrollTop]);\r\n\r\n  return {\r\n    containerRef,\r\n    visibleItems,\r\n    handleScroll,\r\n    totalHeight: items.length * itemHeight\r\n  };\r\n};\r\n\r\n// Hook for optimized data loading\r\nexport const useOptimizedDataLoading = (loadData, dependencies = []) => {\r\n  const [data, setData] = useState(null);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [progress, setProgress] = useState(0);\r\n  const [error, setError] = useState(null);\r\n\r\n  const loadDataOptimized = useCallback(async () => {\r\n    setIsLoading(true);\r\n    setError(null);\r\n    setProgress(0);\r\n\r\n    try {\r\n      const result = await loadData((progressValue) => {\r\n        setProgress(progressValue);\r\n      });\r\n\r\n      // Process data in chunks if it's large\r\n      if (Array.isArray(result) && result.length > 1000) {\r\n        const processedData = await processInChunks(\r\n          result,\r\n          async (item) => ({ ...item, processed: true }),\r\n          1000\r\n        );\r\n        setData(processedData);\r\n      } else {\r\n        setData(result);\r\n      }\r\n    } catch (err) {\r\n      setError(err);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [loadData]);\r\n\r\n  useEffect(() => {\r\n    loadDataOptimized();\r\n  }, dependencies);\r\n\r\n  return { data, isLoading, progress, error, reload: loadDataOptimized };\r\n};\r\n\r\n// Hook for efficient data updates\r\nexport const useEfficientUpdates = (initialData) => {\r\n  const [data, setData] = useState(initialData);\r\n  const updateQueue = useRef([]);\r\n  const isProcessing = useRef(false);\r\n\r\n  const processUpdateQueue = async () => {\r\n    if (isProcessing.current || updateQueue.current.length === 0) return;\r\n\r\n    isProcessing.current = true;\r\n    const updates = [...updateQueue.current];\r\n    updateQueue.current = [];\r\n\r\n    const newData = [...data];\r\n    await processInChunks(updates, update => {\r\n      const { index, value } = update;\r\n      newData[index] = value;\r\n    });\r\n\r\n    setData(newData);\r\n    isProcessing.current = false;\r\n\r\n    if (updateQueue.current.length > 0) {\r\n      processUpdateQueue();\r\n    }\r\n  };\r\n\r\n  const queueUpdate = useCallback((index, value) => {\r\n    updateQueue.current.push({ index, value });\r\n    processUpdateQueue();\r\n  }, []);\r\n\r\n  return [data, queueUpdate];\r\n};\r\n\r\n// Hook for optimized chart data\r\nexport const useOptimizedChartData = (rawData, options = {}) => {\r\n  const {\r\n    maxPoints = 100,\r\n    aggregationType = 'average'\r\n  } = options;\r\n\r\n  const optimizeData = useCallback((data) => {\r\n    if (!data || data.length <= maxPoints) return data;\r\n\r\n    const chunkSize = Math.ceil(data.length / maxPoints);\r\n    const optimizedData = [];\r\n\r\n    for (let i = 0; i < data.length; i += chunkSize) {\r\n      const chunk = data.slice(i, Math.min(i + chunkSize, data.length));\r\n      const aggregatedValue = aggregationType === 'average'\r\n        ? chunk.reduce((sum, item) => sum + item.value, 0) / chunk.length\r\n        : Math.max(...chunk.map(item => item.value));\r\n\r\n      optimizedData.push({\r\n        timestamp: chunk[0].timestamp,\r\n        value: aggregatedValue,\r\n        isAggregated: true,\r\n        dataPoints: chunk.length\r\n      });\r\n    }\r\n\r\n    return optimizedData;\r\n  }, [maxPoints, aggregationType]);\r\n\r\n  const [optimizedChartData, setOptimizedChartData] = useState(() => \r\n    optimizeData(rawData)\r\n  );\r\n\r\n  useEffect(() => {\r\n    setOptimizedChartData(optimizeData(rawData));\r\n  }, [rawData, optimizeData]);\r\n\r\n  return optimizedChartData;\r\n};"
        }
    ]
}