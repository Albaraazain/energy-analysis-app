{
    "sourceFile": "src/utils/data-loader.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1730300716693,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1730300716693,
            "name": "Commit-0",
            "content": "import Papa from 'papaparse';\r\nimport { cleanEnergyData } from './data-types';\r\n\r\nclass DataLoader {\r\n  constructor() {\r\n    this.cache = new Map();\r\n    this.lastUpdate = null;\r\n    this.isLoading = false;\r\n    this.error = null;\r\n  }\r\n\r\n  // Load CSV data from file\r\n  async loadCsvData(fileName) {\r\n    try {\r\n      this.isLoading = true;\r\n      this.error = null;\r\n\r\n      // Check cache first\r\n      if (this.cache.has(fileName)) {\r\n        const cachedData = this.cache.get(fileName);\r\n        // Cache for 5 minutes\r\n        if (Date.now() - this.lastUpdate < 5 * 60 * 1000) {\r\n          return cachedData;\r\n        }\r\n      }\r\n\r\n      const response = await window.fs.readFile(fileName, { encoding: 'utf8' });\r\n      \r\n      return new Promise((resolve, reject) => {\r\n        Papa.parse(response, {\r\n          header: true,\r\n          dynamicTyping: true,\r\n          skipEmptyLines: true,\r\n          complete: (results) => {\r\n            if (results.errors.length > 0) {\r\n              const error = new Error('CSV parsing errors detected');\r\n              error.details = results.errors;\r\n              reject(error);\r\n              return;\r\n            }\r\n\r\n            const cleanedData = this.processData(results.data);\r\n            this.cache.set(fileName, cleanedData);\r\n            this.lastUpdate = Date.now();\r\n            resolve(cleanedData);\r\n          },\r\n          error: (error) => {\r\n            reject(new Error('Failed to parse CSV: ' + error.message));\r\n          }\r\n        });\r\n      });\r\n\r\n    } catch (error) {\r\n      this.error = error;\r\n      throw error;\r\n    } finally {\r\n      this.isLoading = false;\r\n    }\r\n  }\r\n\r\n  // Process and validate the parsed data\r\n  processData(rawData) {\r\n    try {\r\n      // Clean and validate the data\r\n      const cleanedData = cleanEnergyData(rawData);\r\n\r\n      // Sort by timestamp\r\n      cleanedData.sort((a, b) => a.timestamp - b.timestamp);\r\n\r\n      // Check for gaps and anomalies\r\n      this.checkDataQuality(cleanedData);\r\n\r\n      return cleanedData;\r\n    } catch (error) {\r\n      throw new Error('Data processing failed: ' + error.message);\r\n    }\r\n  }\r\n\r\n  // Check for data quality issues\r\n  checkDataQuality(data) {\r\n    if (data.length === 0) {\r\n      throw new Error('No valid data points found');\r\n    }\r\n\r\n    // Check for time gaps larger than expected\r\n    const expectedInterval = this.detectTimeInterval(data);\r\n    const gaps = this.findTimeGaps(data, expectedInterval);\r\n\r\n    if (gaps.length > 0) {\r\n      console.warn('Time gaps detected in data:', gaps);\r\n    }\r\n\r\n    // Check for anomalies in consumption values\r\n    this.detectAnomalies(data);\r\n  }\r\n\r\n  // Detect the time interval between readings\r\n  detectTimeInterval(data) {\r\n    if (data.length < 2) return null;\r\n\r\n    // Look at first few intervals to determine typical spacing\r\n    const intervals = [];\r\n    for (let i = 1; i < Math.min(data.length, 10); i++) {\r\n      intervals.push(data[i].timestamp - data[i-1].timestamp);\r\n    }\r\n\r\n    // Return the median interval\r\n    intervals.sort((a, b) => a - b);\r\n    return intervals[Math.floor(intervals.length / 2)];\r\n  }\r\n\r\n  // Find gaps in time series data\r\n  findTimeGaps(data, expectedInterval) {\r\n    const gaps = [];\r\n    \r\n    if (!expectedInterval) return gaps;\r\n\r\n    for (let i = 1; i < data.length; i++) {\r\n      const interval = data[i].timestamp - data[i-1].timestamp;\r\n      if (interval > expectedInterval * 2) { // Gap is more than double expected\r\n        gaps.push({\r\n          start: data[i-1].timestamp,\r\n          end: data[i].timestamp,\r\n          duration: interval\r\n        });\r\n      }\r\n    }\r\n\r\n    return gaps;\r\n  }\r\n\r\n  // Detect anomalies in consumption values\r\n  detectAnomalies(data) {\r\n    // Calculate mean and standard deviation\r\n    const values = data.map(d => d.consumption);\r\n    const mean = values.reduce((a, b) => a + b) / values.length;\r\n    const stdDev = Math.sqrt(\r\n      values.reduce((sq, n) => sq + Math.pow(n - mean, 2), 0) / values.length\r\n    );\r\n\r\n    // Flag values more than 3 standard deviations from mean\r\n    const anomalies = data.filter(d => \r\n      Math.abs(d.consumption - mean) > 3 * stdDev\r\n    );\r\n\r\n    if (anomalies.length > 0) {\r\n      console.warn('Anomalies detected:', anomalies);\r\n    }\r\n  }\r\n\r\n  // Clear the cache\r\n  clearCache() {\r\n    this.cache.clear();\r\n    this.lastUpdate = null;\r\n  }\r\n}\r\n\r\nexport default new DataLoader();"
        }
    ]
}